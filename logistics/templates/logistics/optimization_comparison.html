<!-- logistics/templates/logistics/optimization_comparison.html -->
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>完整路徑最佳化比較與動態展示</title>
    <!-- 引入 Chart.js，這裡使用最新版本 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* 簡單的 CSS 使頁面更美觀 */
      body { font-family: Arial, sans-serif; margin: 20px; }
      h1, h2 { color: #333; }
      canvas { margin: 20px 0; }
    </style>
</head>
<body>
    <h1>完整路徑最佳化比較與動態展示</h1>
    <p>機器人：<strong>{{ robot.identifier }}</strong></p>

    <!-- 成本比較：Bar Chart -->
    <h2>成本比較 (Bar Chart)</h2>
    <p>原始路徑成本：<strong>{{ orig_cost|floatformat:2 }}</strong> ，最佳化路徑成本：<strong>{{ opt_cost|floatformat:2 }}</strong></p>
    <canvas id="costChart" width="600" height="400"></canvas>
    <script>
        const ctxBar = document.getElementById('costChart').getContext('2d');
        const costChart = new Chart(ctxBar, {
            type: 'bar',
            data: {
                labels: ['原始路徑成本', '最佳化路徑成本'],
                datasets: [{
                    label: '成本比較',
                    data: [{{ orig_cost }}, {{ opt_cost }}],
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.6)',
                        'rgba(54, 162, 235, 0.6)'
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                animation: { duration: 1500 },  // 動畫效果持續1.5秒
                scales: { y: { beginAtZero: true } },
                plugins: {
                    tooltip: { enabled: true }
                }
            }
        });
    </script>

    <!-- 累積成本變化：Line Chart -->
    <h2>累積成本變化 (Line Chart)</h2>
    <p>展示機器人每次運送後的累積成本，藉由不同線條分別代表原始與最佳化路徑。</p>
    <canvas id="routeChart" width="800" height="400"></canvas>
    <script>
        const originalCum = {{ original_cum|safe }};
        const optimizedCum = {{ optimized_cum|safe }};
        // 以最大長度作為 x 軸標籤數量
        const maxLen = Math.max(originalCum.length, optimizedCum.length);
        const labels = [];
        for (let i = 1; i <= maxLen; i++) {
            labels.push('第 ' + i + ' 次');
        }
        const ctxLine = document.getElementById('routeChart').getContext('2d');
        const routeChart = new Chart(ctxLine, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: '原始路徑累積成本',
                        data: originalCum,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        fill: false,
                        tension: 0.2, // 輕微平滑曲線效果
                        pointRadius: 5
                    },
                    {
                        label: '最佳化路徑累積成本',
                        data: optimizedCum,
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: false,
                        tension: 0.2,
                        pointRadius: 5
                    }
                ]
            },
            options: {
                animation: { duration: 1500 },
                responsive: true,
                scales: {
                    x: { title: { display: true, text: '運送次數' } },
                    y: { beginAtZero: true, title: { display: true, text: '累積成本 (距離)' } }
                }
            }
        });
    </script>

    <!-- 動態展示機器人移動軌跡：Scatter Chart 動畫呈現 -->
    <!-- 分列顯示兩張 scatter chart -->
    <h2>機器人移動軌跡動畫</h2>
    <div style="display: flex; justify-content: space-between;">
        <!-- 原始路徑圖 -->
        <div style="flex: 1; margin-right: 10px; text-align: center;">
            <h3>原始路徑</h3>
            <canvas id="origChart" width="400" height="400"></canvas>
            <div>
                <button id="origPlayBtn">播放</button>
                <button id="origPauseBtn">暫停</button>
                <button id="origResetBtn">重置</button>
            </div>
        </div>
        <!-- 最佳化路徑圖 -->
        <div style="flex: 1; margin-left: 10px; text-align: center;">
            <h3>最佳化路徑</h3>
            <canvas id="optChart" width="400" height="400"></canvas>
            <div>
                <button id="optPlayBtn">播放</button>
                <button id="optPauseBtn">暫停</button>
                <button id="optResetBtn">重置</button>
            </div>
        </div>
    </div>
    <script>
        // 從後端傳入原始與最佳化座標資料，格式為 [{x: number, y: number}, ...]
        const originalCoords = {{ original_coords|safe }};
        const optimizedCoords = {{ optimized_coords|safe }};
        
        // 轉換成 Chart.js 所需的格式
        const origFullData = originalCoords.map(coord => ({ x: coord.x, y: coord.y }));
        const optFullData = optimizedCoords.map(coord => ({ x: coord.x, y: coord.y }));
        
        // 初始顯示資料皆為空陣列，獨立控制兩張圖
        let origDisplayedData = [];
        let optDisplayedData = [];
        let origCurrentIndex = 0;
        let optCurrentIndex = 0;
        let origIntervalId = null;
        let optIntervalId = null;
        
        // 建立原始路徑的 scatter chart
        const ctxOrig = document.getElementById('origChart').getContext('2d');
        const origChart = new Chart(ctxOrig, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: '原始路徑',
                    data: origDisplayedData,
                    showLine: true,
                    fill: false,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.4)',
                    pointRadius: 5,
                    tension: 0.2
                }]
            },
            options: {
                responsive: true,
                animation: false, // 關閉內建動畫，使用自訂更新
                scales: {
                    x: { type: 'linear', position: 'bottom', title: { display: true, text: 'X 座標' }},
                    y: { title: { display: true, text: 'Y 座標' }}
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return '(' + context.parsed.x + ', ' + context.parsed.y + ')';
                            }
                        }
                    }
                }
            }
        });
        
        // 建立最佳化路徑的 scatter chart
        const ctxOpt = document.getElementById('optChart').getContext('2d');
        const optChart = new Chart(ctxOpt, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: '最佳化路徑',
                    data: optDisplayedData,
                    showLine: true,
                    fill: false,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.4)',
                    pointRadius: 5,
                    tension: 0.2
                }]
            },
            options: {
                responsive: true,
                animation: false,
                scales: {
                    x: { type: 'linear', position: 'bottom', title: { display: true, text: 'X 座標' }},
                    y: { title: { display: true, text: 'Y 座標' }}
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return '(' + context.parsed.x + ', ' + context.parsed.y + ')';
                            }
                        }
                    }
                }
            }
        });
        
        // 每 0.5 秒更新原始路徑圖表
        function updateOrigChart() {
            if (origCurrentIndex < origFullData.length) {
                origDisplayedData.push(origFullData[origCurrentIndex]);
                origChart.update();
                origCurrentIndex++;
            } else {
                clearInterval(origIntervalId);
                origIntervalId = null;
            }
        }
        
        // 每 0.5 秒更新最佳化路徑圖表
        function updateOptChart() {
            if (optCurrentIndex < optFullData.length) {
                optDisplayedData.push(optFullData[optCurrentIndex]);
                optChart.update();
                optCurrentIndex++;
            } else {
                clearInterval(optIntervalId);
                optIntervalId = null;
            }
        }
        
        // 控制原始路徑圖表的動畫
        function origPlay() {
            if (!origIntervalId) {
                origIntervalId = setInterval(updateOrigChart, 500);
            }
        }
        function origPause() {
            if (origIntervalId) {
                clearInterval(origIntervalId);
                origIntervalId = null;
            }
        }
        function origReset() {
            origPause();
            origDisplayedData.length = 0;
            origCurrentIndex = 0;
            origChart.update();
        }
        
        // 控制最佳化路徑圖表的動畫
        function optPlay() {
            if (!optIntervalId) {
                optIntervalId = setInterval(updateOptChart, 500);
            }
        }
        function optPause() {
            if (optIntervalId) {
                clearInterval(optIntervalId);
                optIntervalId = null;
            }
        }
        function optReset() {
            optPause();
            optDisplayedData.length = 0;
            optCurrentIndex = 0;
            optChart.update();
        }
        
        // 綁定按鈕事件
        document.getElementById('origPlayBtn').addEventListener('click', origPlay);
        document.getElementById('origPauseBtn').addEventListener('click', origPause);
        document.getElementById('origResetBtn').addEventListener('click', origReset);
        document.getElementById('optPlayBtn').addEventListener('click', optPlay);
        document.getElementById('optPauseBtn').addEventListener('click', optPause);
        document.getElementById('optResetBtn').addEventListener('click', optReset);
    </script>
</body>
</html>
